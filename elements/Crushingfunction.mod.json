{
  "_fv": 77,
  "_type": "function",
  "definition": {
    "code": "// Define constants\ndouble ENERGY_CAPACITY = 400000;\ndouble ENERGY_PER_REDSTONE = 2000;\ndouble ENERGY_PER_REDSTONE_TORCH = 500;\ndouble ENERGY_PER_REDSTONE_BLOCK = 18000;\ndouble ENERGY_PER_OPERATION = 1000;\ndouble CRUSHING_TIME = 60; // Ticks to crush one item\n\n// Get current energy and progress values\ndouble currentEnergy = 0;\nif (blockEntity.getCapability(ForgeCapabilities.ENERGY, null).isPresent()) {\n    currentEnergy = blockEntity.getCapability(ForgeCapabilities.ENERGY, null).resolve().get().getEnergyStored();\n}\n\ndouble crushingProgress = 0;\nif (blockEntity.getPersistentData().contains(\"crushingProgress\")) {\n    crushingProgress = blockEntity.getPersistentData().getDouble(\"crushingProgress\");\n}\n\n// Check fuel slot (slot 0)\nif (!blockEntity.getItem(0).isEmpty()) {\n    Item fuelItem = blockEntity.getItem(0).getItem();\n    boolean isFuel = false;\n    double energyToAdd = 0;\n    \n    // Check if item is valid redstone fuel\n    if (fuelItem.equals(Items.REDSTONE)) {\n        isFuel = true;\n        energyToAdd = ENERGY_PER_REDSTONE;\n    } else if (fuelItem.equals(Items.REDSTONE_TORCH)) {\n        isFuel = true;\n        energyToAdd = ENERGY_PER_REDSTONE_TORCH;\n    } else if (fuelItem.equals(Items.REDSTONE_BLOCK)) {\n        isFuel = true;\n        energyToAdd = ENERGY_PER_REDSTONE_BLOCK;\n    } else if (fuelItem.getTags().contains(new ResourceLocation(\"rmod:redstone\"))) {\n        isFuel = true;\n        energyToAdd = ENERGY_PER_REDSTONE; // Default value for tagged items\n    }\n    \n    // Process fuel if valid and there's room for energy\n    if (isFuel && currentEnergy + energyToAdd <= ENERGY_CAPACITY) {\n        // Consume one fuel item\n        ItemStack fuelStack = blockEntity.getItem(0);\n        fuelStack.shrink(1);\n        blockEntity.setItem(0, fuelStack);\n        \n        // Add energy\n        if (blockEntity.getCapability(ForgeCapabilities.ENERGY, null).isPresent()) {\n            blockEntity.getCapability(ForgeCapabilities.ENERGY, null).resolve().get()\n                .receiveEnergy((int)energyToAdd, false);\n            currentEnergy += energyToAdd;\n        }\n        \n        // Play sound and visual effects\n        if (world instanceof Level _level) {\n            if (!_level.isClientSide()) {\n                _level.playSound(null, new BlockPos(x, y, z), \n                    ForgeRegistries.SOUND_EVENTS.getValue(new ResourceLocation(\"block.redstone_torch.burnout\")), \n                    SoundSource.BLOCKS, 0.5f, 1.0f);\n            } else {\n                _level.addParticle(ParticleTypes.FLAME, x + 0.5, y + 1.0, z + 0.5, 0, 0.05, 0);\n            }\n        }\n    }\n}\n\n// Process input (slot 1) if there's enough energy\nif (!blockEntity.getItem(1).isEmpty() && blockEntity.getItem(2).isEmpty() && currentEnergy >= ENERGY_PER_OPERATION) {\n    Item inputItem = blockEntity.getItem(1).getItem();\n    boolean validInput = false;\n    ItemStack outputStack = ItemStack.EMPTY;\n    \n    // Check if input is valid (has forge:ores tag)\n    if (inputItem.getTags().contains(new ResourceLocation(\"forge:ores\"))) {\n        validInput = true;\n        \n        // Determine output based on input\n        // This is where you'd implement your ore-to-dust conversion logic\n        // For example:\n        if (inputItem.equals(Items.IRON_INGOT){\n            outputStack = new ItemStack(ForgeRegistries.ITEMS.getValue(\n                new ResourceLocation(\"modid:irondust\")));\n        } else if (inputItem.equals(Items.GOLD_INGOT) {\n            outputStack = new ItemStack(ForgeRegistries.ITEMS.getValue(\n                new ResourceLocation(\"modid:golddust\")));\n        } else if (inputItem.equals(Items.COPPER_INGOT){\n            outputStack = new ItemStack(ForgeRegistries.ITEMS.getValue(\n                new ResourceLocation(\"modid:copperdust\")));\n        } else if (inputItem.equals(Items.DIAMOND) {\n            outputStack = new ItemStack(ForgeRegistries.ITEMS.getValue(\n                new ResourceLocation(\"modid:diamonddust\")));\n\t\t} else if (inputItem.equals(Items.EMERALD) {\n            outputStack = new ItemStack(ForgeRegistries.ITEMS.getValue(\n                new ResourceLocation(\"modid:emeralddust\")));\n        \n        // Check if output is in the crusher outputs tag\n        if (!outputStack.isEmpty() && \n            outputStack.getItem().getTags().contains(new ResourceLocation(\"mod:crusheroutputs\"))) {\n            // Valid input with valid output\n            // Continue with crushing process\n        } else {\n            validInput = false; // Output not in crusheroutputs tag\n        }\n    }\n    \n    if (validInput && !outputStack.isEmpty()) {\n        // Increment crushing progress\n        crushingProgress += 1;\n        \n        // Consume energy\n        if (blockEntity.getCapability(ForgeCapabilities.ENERGY, null).isPresent()) {\n            blockEntity.getCapability(ForgeCapabilities.ENERGY, null).resolve().get()\n                .extractEnergy((int)(ENERGY_PER_OPERATION / CRUSHING_TIME), false);\n            currentEnergy -= (ENERGY_PER_OPERATION / CRUSHING_TIME);\n        }\n        \n        // Check if crushing is complete\n        if (crushingProgress >= CRUSHING_TIME) {\n            // Consume input\n            ItemStack inputStack = blockEntity.getItem(1);\n            inputStack.shrink(1);\n            blockEntity.setItem(1, inputStack);\n            \n            // Add output\n            blockEntity.setItem(2, outputStack);\n            \n            // Reset progress\n            crushingProgress = 0;\n            \n            // Play completion sound and particles\n            if (world instanceof Level _level) {\n                if (!_level.isClientSide()) {\n                    _level.playSound(null, new BlockPos(x, y, z), \n                        ForgeRegistries.SOUND_EVENTS.getValue(new ResourceLocation(\"block.grindstone.use\")), \n                        SoundSource.BLOCKS, 1.0f, 1.0f);\n                } else {\n                    for (int i = 0; i < 5; i++) {\n                        _level.addParticle(ParticleTypes.CRIT, \n                            x + 0.5, y + 0.7, z + 0.5, \n                            Math.random() * 0.2 - 0.1, \n                            Math.random() * 0.2, \n                            Math.random() * 0.2 - 0.1);\n                    }\n                }\n            }\n        }\n        \n        // Visual effects during processing\n        if (world instanceof Level _level && _level.isClientSide() && Math.random() < 0.25) {\n            _level.addParticle(ParticleTypes.SMOKE, \n                x + 0.5, y + 0.7, z + 0.5, \n                0, 0.05, 0);\n        }\n    } else {\n        // Invalid input or output, reset progress\n        crushingProgress = 0;\n    }\n} else {\n    // No valid input or not enough energy, reset progress\n    if (crushingProgress > 0) {\n        crushingProgress = 0;\n    }\n}\n\n// Save crushing progress\nblockEntity.getPersistentData().putDouble(\"crushingProgress\", crushingProgress);\n\n// Update block state if needed (for visual changes)\nif (world instanceof Level _level) {\n    if (!_level.isClientSide()) {\n        _level.sendBlockUpdated(new BlockPos(x, y, z), \n            _level.getBlockState(new BlockPos(x, y, z)), \n            _level.getBlockState(new BlockPos(x, y, z)), 3);\n    }\n}",
    "name": "crushingfunction",
    "namespace": "mod"
  }
}